#!/bin/bash

# –°–∫—Ä–∏–ø—Ç –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è API endpoints –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ
# –ò—Å–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–æ–±–ª–µ–º—É "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞—É–∫—Ü–∏–æ–Ω–æ–≤"

echo "üîß –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ API endpoints –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Å–µ—Ä–≤–µ—Ä–µ..."
echo "===================================================="

# –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –º—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
if [ ! -f "/var/www/wolmar-parser/server.js" ]; then
    echo "‚ùå –û—à–∏–±–∫–∞: –°–∫—Ä–∏–ø—Ç –¥–æ–ª–∂–µ–Ω –∑–∞–ø—É—Å–∫–∞—Ç—å—Å—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ –≤ /var/www/wolmar-parser"
    exit 1
fi

cd /var/www/wolmar-parser

echo "üìä –¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å:"
git status
git branch --show-current

echo ""
echo "üîÑ –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–Ω—É—é –≤–µ—Ç–∫—É..."
git checkout catalog-parser --force
git pull origin catalog-parser

echo ""
echo "üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º API endpoints –≤ server.js..."

# –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ API endpoints –¥–ª—è –∞—É–∫—Ü–∏–æ–Ω–æ–≤
if grep -q "/api/auctions" server.js; then
    echo "‚úÖ API endpoints –¥–ª—è –∞—É–∫—Ü–∏–æ–Ω–æ–≤ –Ω–∞–π–¥–µ–Ω—ã"
else
    echo "‚ùå API endpoints –¥–ª—è –∞—É–∫—Ü–∏–æ–Ω–æ–≤ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç"
    echo "üîÑ –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–∑ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏..."
    
    if [ -f "server.js.backup" ]; then
        echo "üì¶ –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–∑ server.js.backup..."
        cp server.js.backup server.js
        echo "‚úÖ –§–∞–π–ª –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–∑ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏"
    else
        echo "‚ùå –†–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        echo "üîÑ –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–µ API endpoints..."
        
        # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —Å API endpoints
        cat > temp_api_endpoints.js << 'EOF'
// API endpoints –¥–ª—è –∞—É–∫—Ü–∏–æ–Ω–æ–≤
app.get('/api/auctions', async (req, res) => {
    try {
        const query = `
            SELECT 
                auction_number,
                COUNT(*) as lots_count,
                MIN(auction_end_date) as start_date,
                MAX(auction_end_date) as end_date,
                SUM(winning_bid) as total_value,
                AVG(winning_bid) as avg_bid,
                MAX(winning_bid) as max_bid,
                MIN(winning_bid) as min_bid
            FROM auction_lots 
            WHERE auction_number IS NOT NULL
            GROUP BY auction_number
            ORDER BY auction_number DESC
        `;
        
        const result = await pool.query(query);
        res.json(result.rows);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞—É–∫—Ü–∏–æ–Ω–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ–± –∞—É–∫—Ü–∏–æ–Ω–∞—Ö' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –ª–æ—Ç—ã –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∞—É–∫—Ü–∏–æ–Ω–∞
app.get('/api/auctions/:auctionNumber/lots', async (req, res) => {
    try {
        const { auctionNumber } = req.params;
        const { page = 1, limit = 20, search, metal, condition, year, minPrice, maxPrice } = req.query;
        
        const offset = (page - 1) * limit;
        let whereClause = 'WHERE auction_number = $1';
        const queryParams = [auctionNumber];
        let paramCount = 1;
        
        if (search) {
            paramCount++;
            whereClause += ` AND coin_description ILIKE $${paramCount}`;
            queryParams.push(`%${search}%`);
        }
        
        if (metal) {
            paramCount++;
            whereClause += ` AND metal = $${paramCount}`;
            queryParams.push(metal);
        }
        
        if (condition) {
            paramCount++;
            whereClause += ` AND condition = $${paramCount}`;
            queryParams.push(condition);
        }
        
        if (year) {
            paramCount++;
            whereClause += ` AND year = $${paramCount}`;
            queryParams.push(year);
        }
        
        if (minPrice) {
            paramCount++;
            whereClause += ` AND winning_bid >= $${paramCount}`;
            queryParams.push(parseFloat(minPrice));
        }
        
        if (maxPrice) {
            paramCount++;
            whereClause += ` AND winning_bid <= $${paramCount}`;
            queryParams.push(parseFloat(maxPrice));
        }
        
        const query = `
            SELECT 
                id, lot_number, coin_description, avers_image_url, revers_image_url,
                winner_login, winning_bid, auction_end_date, bids_count,
                metal, condition, year
            FROM auction_lots 
            ${whereClause}
            ORDER BY lot_number::int
            LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}
        `;
        
        queryParams.push(parseInt(limit), offset);
        
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ª–æ—Ç–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –ª–æ—Ç–∞—Ö' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–æ—Ç–µ
app.get('/api/lots/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const query = `
            SELECT 
                id, lot_number, auction_number, coin_description,
                avers_image_url, revers_image_url, winner_login,
                winning_bid, auction_end_date, bids_count,
                metal, condition, year
            FROM auction_lots 
            WHERE id = $1
        `;
        
        const result = await pool.query(query, [id]);
        
        if (result.rows.length === 0) {
            return res.status(404).json({ error: '–õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        res.json(result.rows[0]);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ª–æ—Ç–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –ª–æ—Ç–µ' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∞—É–∫—Ü–∏–æ–Ω–∞
app.get('/api/auctions/:auctionNumber/stats', async (req, res) => {
    try {
        const { auctionNumber } = req.params;
        const query = `
            SELECT 
                COUNT(*) as total_lots,
                SUM(winning_bid) as total_value,
                AVG(winning_bid) as avg_bid,
                MAX(winning_bid) as max_bid,
                MIN(winning_bid) as min_bid,
                COUNT(DISTINCT winner_login) as unique_winners,
                COUNT(DISTINCT metal) as unique_metals,
                COUNT(DISTINCT condition) as unique_conditions
            FROM auction_lots 
            WHERE auction_number = $1
        `;
        
        const result = await pool.query(query, [auctionNumber]);
        res.json(result.rows[0]);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∞—É–∫—Ü–∏–æ–Ω–∞' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
app.get('/api/filters', async (req, res) => {
    try {
        const { auctionNumber } = req.query;
        let whereClause = '';
        const queryParams = [];
        
        if (auctionNumber) {
            whereClause = 'WHERE auction_number = $1';
            queryParams.push(auctionNumber);
        }
        
        const query = `
            SELECT 
                metal,
                condition,
                year
            FROM auction_lots 
            ${whereClause}
            GROUP BY metal, condition, year
            ORDER BY metal, condition, year
        `;
        
        const result = await pool.query(query, queryParams);
        
        const filters = {
            metals: [...new Set(result.rows.map(row => row.metal).filter(Boolean))],
            conditions: [...new Set(result.rows.map(row => row.condition).filter(Boolean))],
            years: [...new Set(result.rows.map(row => row.year).filter(Boolean))].sort()
        };
        
        res.json(filters);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤' });
    }
});
EOF
        
        echo "üìù –î–æ–±–∞–≤–ª—è–µ–º API endpoints –≤ server.js..."
        # –î–æ–±–∞–≤–ª—è–µ–º API endpoints –≤ server.js
        # –ù–∞—Ö–æ–¥–∏–º –º–µ—Å—Ç–æ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ (–ø–µ—Ä–µ–¥ catch-all route)
        sed -i '/app.get('\''\*'\'',/i\
// API endpoints –¥–ª—è –∞—É–∫—Ü–∏–æ–Ω–æ–≤\
' server.js
        
        # –í—Å—Ç–∞–≤–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ temp —Ñ–∞–π–ª–∞
        sed -i '/\/\/ API endpoints –¥–ª—è –∞—É–∫—Ü–∏–æ–Ω–æ–≤/r temp_api_endpoints.js' server.js
        
        # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
        rm temp_api_endpoints.js
        
        echo "‚úÖ API endpoints –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ server.js"
    fi
fi

echo ""
echo "üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞..."
pm2 restart wolmar-parser

if [ $? -eq 0 ]; then
    echo "‚úÖ –û—Å–Ω–æ–≤–Ω–æ–π —Å–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω"
else
    echo "‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞"
    exit 1
fi

echo ""
echo "üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–±–æ—Ç—ã API..."
sleep 3

curl -s http://localhost:3001/api/auctions > /dev/null
if [ $? -eq 0 ]; then
    echo "‚úÖ API –∞—É–∫—Ü–∏–æ–Ω–æ–≤ —Ä–∞–±–æ—Ç–∞–µ—Ç"
else
    echo "‚ùå API –∞—É–∫—Ü–∏–æ–Ω–æ–≤ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç"
fi

echo ""
echo "‚úÖ –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–ï –ó–ê–í–ï–†–®–ï–ù–û!"
echo "üåê –û—Å–Ω–æ–≤–Ω–æ–π —Å–µ—Ä–≤–µ—Ä: http://46.173.19.68:3001"
echo "üìä API –∞—É–∫—Ü–∏–æ–Ω–æ–≤: http://46.173.19.68:3001/api/auctions"
